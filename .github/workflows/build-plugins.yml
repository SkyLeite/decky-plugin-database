name: Build Plugins

on:
  push:
    branches:
      - main
      - backend-builder
      - testing
    paths:
      - "plugins/**"
      - ".github/workflows/build-plugins.yml"
  pull_request_target:
    branches: ["*"]
  workflow_dispatch:
    inputs:
      upload:
        type: boolean
        description: Re-upload the plugins to the store

jobs:
  build:
    name: Build updated plugins
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        if: ${{ !env.ACT }}
        uses: actions/checkout@8230315d06ad95c617244d2f265d237a1682d445
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0
          submodules: "recursive"
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Wait for other runs to complete
        if: ${{ !env.ACT }}
        uses: pau1ocampos/turnstyle@17e7c2e349edeb2fc92d15e99f389c6011e02956
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect edited files/plugins
        id: list-files
        run: |
          pushd plugins
          files=()
          if [[ "${{ steps.changed-files.outputs.all_changed_files }}" == *".github/workflows/build-plugins.yml"* || "${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.upload) && 'true' }}" == "true" ]];
          then
            echo "Rebuilding all plugins due to workflow edit"
            for file in ./plugins/*; do
              files+=($(cut -d/ -f3 <<< $file))
            done
          else
            rest="${{ steps.changed-files.outputs.all_changed_files }}"
            while [ -n "$rest" ] ; do
              str=${rest%%,*}
              [ "$rest" = "${rest/,/}" ] && rest= || rest=${rest#*,}
              files+=($(cut -d/ -f2 <<< $str))
            done <<< "$files"
            printf "%s\n" "${files[@]}" | sort -u
          fi
          popd
          IFS=$'\n' sorted=($(sort -u <<<"${files[@]}"))
          unset $IFS
          echo "${sorted[@]}"
          echo edited_files=${sorted[@]} >> $GITHUB_OUTPUT

      - name: Build plugins
        run: |
          # Read changed files
          IFS=' ' read -ra files <<< "${{ steps.list-files.outputs.edited_files }}"

          # Download decky
          curl -L -o decky https://github.com/SteamDeckHomebrew/cli/releases/download/0.0.1-alpha.4/decky
          chmod +x decky

          pushd plugins

          for plugin in ./*; do
            echo "Building $plugin"
            ../decky plugin build -b -o /tmp/output $plugin
          done

      - name: Upload Artifacts to Github
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8
        with:
          name: plugins
          path: /tmp/output/*

      - name: Upload plugins to store
        if: ${{ !env.ACT }}
        id: upload-plugins
        run: |
          shopt -s dotglob
          for zipname in /tmp/output/*.zip; do
            pluginjson=$(unzip -p $zipname "$plugin/plugin.json")
            packagejson=$(unzip -p $zipname "$plugin/package.json")
            donotupload=$(jq -r '.publish | any(.tags[] == "dnu"; .)' <<<"$pluginjson")
            if [[ "$donotupload" == "false" ]]; then
              curl \
                -X POST \
                -H "Authorization: ${SUBMIT_AUTH_KEY}" \
                -F "name=$(jq -r '.name' <<<"$pluginjson")" \
                -F "author=$(jq -r '.author' <<<"$pluginjson")" \
                -F "description=$(jq -r '.publish.description' <<<"$pluginjson")" \
                -F "tags=$(jq -r '.publish.tags|join(",")' <<<"$pluginjson")" \
                -F "version_name=$(jq -r '.version' <<<"$packagejson")" \
                -F "image=$(jq -r '.publish.image' <<<"$pluginjson")" \
                -F "file=@${zipname}" ${STORE_URL}/__submit
            else
              echo "Plugin is designated as 'do not upload', likely a template or CI demonstration."
            fi
          done
        env:
          SUBMIT_AUTH_KEY: ${{ secrets.SUBMIT_AUTH_KEY }}
          STORE_URL: ${{ secrets.STORE_URL }}
