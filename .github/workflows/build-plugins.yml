name: Build Plugins

on:
  push:
    branches:
      - main
      - backend-builder
      - use-cli
    paths:
      - "plugins/**"
      - ".github/workflows/build-plugins.yml"
  pull_request_target:
    branches: ['*']
  workflow_dispatch:
    inputs:
      upload:
        type: boolean
        description: Re-upload the plugins to the store

jobs:
  build:
    name: Build updated plugins
    runs-on: ubuntu-latest
    environment:
      name: ${{ (github.ref == 'refs/heads/main' && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.upload))) && 'env' || 'testing_env' }}    

    steps:
    - name: Checkout
      if: ${{ !env.ACT }}
      uses: actions/checkout@8230315d06ad95c617244d2f265d237a1682d445
      with:
        ref: ${{ github.event.pull_request.head.sha || github.sha }}
        fetch-depth: 0
        submodules: "recursive"
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Get changed files
      id: changed-files
      env:
        isPr: ${{ github.event_name == 'pull_request_target' }}
        buildAll: ${{ inputs.build_all }}
      run: |
        # Returns a list of paths relative to the git repository of the files that changed
        # In pull requests, it diffs files between the last commit in the pull request and main
        # In push events, it diffs between the current commit and the previous

        # Paths to be included in the diff
        PATHS=(plugins .github/workflows/build-plugins.yml)

        # Find refs to be diffed
        if [[ $isPr == "true" ]]; then
          echo "PR detected. beep boop"

          # Fetch all remotes so we can properly diff
          git fetch --no-tags --prune --depth=1 origin +refs/heads/*:refs/remotes/origin/*

          # Diff with the ref of the target branch
          REF=origin/${{ github.base_ref }}
        else
          echo "This is probably a push to main or something"
          # Diff with previous commit
          REF=HEAD^
        fi

        FILES=$(git diff ${REF[@]} --name-only --submodule=diff -- ${PATHS[@]} | jq -Rsc 'split("\n")[:-1] | join (",")')
        echo "all_changed_files=$FILES" >> $GITHUB_OUTPUT

    - name: Wait for other runs to complete
      if: ${{ !env.ACT }}
      uses: pau1ocampos/turnstyle@17e7c2e349edeb2fc92d15e99f389c6011e02956
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Detect edited files/plugins
      id: list-files
      run: |
        pushd plugins
        files=()
        echo "Checking for file edits"
        rest="${{ steps.changed-files.outputs.all_changed_files }}"
        while [ -n "$rest" ] ; do
          str=${rest%%,*}
          [ "$rest" = "${rest/,/}" ] && rest= || rest=${rest#*,}
          edited_files+=($(cut -d/ -f2 <<< $str))
        done <<< "$edited_files"
        if [[ "${{ steps.changed-files.outputs.all_changed_files }}" == *".github/workflows/build-plugins.yml"* || "${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.upload) && 'true' }}" == "true" ]]; 
        then
          echo "Rebuilding all plugins due to workflow edit"
          for file in ./plugins/*; do
            files+=($(cut -d/ -f3 <<< $file))
          done
          echo "Checking to see what files were actually edited"
          rest="${{ steps.changed-files.outputs.all_changed_files }}"
          while [ -n "$rest" ] ; do
            str=${rest%%,*}
            [ "$rest" = "${rest/,/}" ] && rest= || rest=${rest#*,}
            edited_files+=($(cut -d/ -f2 <<< $str))
          done <<< "$edited_files"
          printf "%s\n" "${edited_files[@]}" | sort -u
        else
          files=$edited_files
        fi
        IFS=$'\n' sorted=($(sort -u <<<"${files[@]}"))
        unset $IFS
        IFS=$'\n' sorted_edited=($(sort -u <<<"${edited_files[@]}"))
        unset $IFS
        echo "files_out=${sorted[@]}" >> $GITHUB_ENV
        echo "edited_files_out=${sorted_edited[@]}" >> $GITHUB_ENV
        popd
        echo "Sorted "Changed" Files:"
        echo "${sorted[@]}"
        echo "Sorted Edited Files:"
        echo "${sorted_edited[@]}"

    - name: Debug
      run: |
        echo "File"
        echo "${{ env.files_out }}"

        echo "Edited"
        echo "${{ env.edited_files_out }}"

    - name: Download Decky CLI
      run: |
        mkdir /tmp/decky-cli
        curl -L -o /tmp/decky-cli/decky "https://github.com/SteamDeckHomebrew/cli/releases/download/0.0.1-alpha.4/decky"
        chmod +x /tmp/decky-cli/decky

        echo "/tmp/decky-cli" >> $GITHUB_PATH

    - name: Build plugin backends
      run: |
        IFS=' ' read -ra files <<< "${{ env.files_out }}"
        for plugin in $(printf "%s\n" "${files[@]}" | sort -u); do
          decky plugin build -b plugins/$plugin -o /tmp/output
        done

    - name: Upload Artifacts to Github
      if: ${{ !env.ACT }}
      uses: actions/upload-artifact@3cea5372237819ed00197afe530f5a7ea3e805c8
      with:
        name: plugins
        path: /tmp/output/*.zip

    - name: Upload plugins to store
      if: ${{ !env.ACT }}
      id: upload-plugins
      run: |
        shopt -s dotglob
        for plugin in /tmp/output/*; do
          zipname=/tmp/zips/$(basename ${plugin}).zip
          pushd $plugin
          donotupload=$(jq -r '.publish | any(.tags[] == "dnu"; .)' ./plugin.json)
          IFS=' ' read -ra edited_files <<< "${{ env.edited_files_out }}"
          if [[ "$donotupload" == "false" ]]; then
            for edited_plugin in $(printf "%s\n" "${edited_files[@]}" | sort -u); do
              plugin_nodir=$(echo "$plugin" | sed -e "s|^/tmp/output/||")
              if [[ "$plugin_nodir" =~ "$edited_plugin" ]]; then
                curl -X POST -H "Authorization: ${SUBMIT_AUTH_KEY}" -F "name=$(jq -r '.name' ./plugin.json)" -F "author=$(jq -r '.author' ./plugin.json)" -F "description=$(jq -r '.publish.description' ./plugin.json)" -F "tags=$(jq -r '.publish.tags|join(",")' ./plugin.json)" -F "version_name=$(jq -r '.version' ./package.json)" -F "image=$(jq -r '.publish.image' ./plugin.json)" -F "file=@${zipname}" ${STORE_URL}/__submit
              else
                echo "Plugin $plugin could not be uploaded as it was built only to test CI changes."
                break
              fi
            done
          else
            echo "Plugin $plugin is designated as 'do not upload', likely a template or CI demonstration."
          fi
          unset $IFS
          popd
        done
      env:
        SUBMIT_AUTH_KEY: ${{ secrets.SUBMIT_AUTH_KEY }}
        STORE_URL: ${{ secrets.STORE_URL }}
